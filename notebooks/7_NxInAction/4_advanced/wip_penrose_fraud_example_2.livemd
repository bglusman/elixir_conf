# Mix.Install Penrose

```elixir
Mix.install([
  {:axon, "~> 0.2.0-dev", github: "elixir-nx/axon"},
  {:exla, "~> 0.3.0-dev", github: "elixir-nx/nx", sparse: "exla"},
  {:nx, "~> 0.3.0-dev", github: "elixir-nx/nx", sparse: "nx", override: true},
  {:explorer, "~> 0.2.0"},
  {:kino, "~> 0.6.2"},
  {:kino_vega_lite, "~> 0.1.1"},
  {:req, "~> 0.3.0"},
  {:vega_lite, "~> 0.1.4"}
])
```

## Get the data - Credit Card Fraud

The dataset for this experiment is the [Credit Card Fraud Prevention](https://www.kaggle.com/datasets/mlg-ulb/creditcardfraud) set.

```elixir
df =
  Explorer.DataFrame.from_csv!("Projects/elixir_conf/data/creditcard.csv",
    dtypes: [{"Time", :float}]
  )
```

## Size the data

Determine how many rows are in the dataset. Use that number to determine the size needed for training and testing.

```elixir
sample_size = Explorer.DataFrame.n_rows(df) |> IO.inspect(label: "Number of rows")

# 85% of the data set to use for training; 15% for testing
train_size = ceil(0.85 * sample_size)
train_size = ceil(0.85 * sample_size) |> IO.inspect(label: "Training size")
test_size = (sample_size - train_size) |> IO.inspect(label: "Test size")

:ok
```

```elixir
train_df = Explorer.DataFrame.slice(df, 0, train_size)
test_df = Explorer.DataFrame.slice(df, 0, test_size)

# Select a set with the target ("Class") and without for training and testing
train_df_inputs = Explorer.DataFrame.select(train_df, &(&1 == "Class"), :drop)
train_df_targets = Explorer.DataFrame.select(train_df, &(&1 == "Class"), :keep)
test_df_inputs = Explorer.DataFrame.select(test_df, &(&1 == "Class"), :drop)
test_df_targets = Explorer.DataFrame.select(test_df, &(&1 == "Class"), :keep)

:ok
```

```elixir
# Function to convert the datafram to tensors
to_tensor = fn data_frame ->
  data_frame
  |> Explorer.DataFrame.names()
  |> Enum.map(
    &(Explorer.Series.to_tensor(data_frame[&1])
      |> Nx.new_axis(-1))
  )
  |> Nx.concatenate(axis: 1)
end
```

```elixir
# convert sets to tensors
train_inputs = to_tensor.(train_df_inputs)
train_targets = to_tensor.(train_df_targets)
test_inputs = to_tensor.(test_df_inputs)
test_targets = to_tensor.(test_df_targets)

# convert sets tensors to lists of tensors
train_batch_inputs = Nx.to_batched(train_inputs, 2048, leftover: :repeat)
train_batch_targets = Nx.to_batched(train_targets, 2048, leftover: :repeat)
test_batch_inputs = Nx.to_batched(test_inputs, 2048, leftover: :repeat)
test_batch_targets = Nx.to_batched(test_targets, 2048, leftover: :repeat)

:ok
```

```elixir
# Zip the batches together
train_batch = Stream.zip(train_batch_inputs, train_batch_targets)
test_batch = Stream.zip(test_batch_inputs, test_batch_targets)

:ok
```

```elixir
train_max = Nx.reduce_max(train_inputs, axes: [0], keep_axes: true)

# Function to normalize the data to a value between 0 and 1
normalize = fn {batch, target} ->
  {Nx.divide(batch, train_max), target}
end

training_data = train_batch |> Stream.map(&Nx.Defn.jit(normalize, [&1], compiler: EXLA))
```

## Train the data!

```elixir
# Define the model
model =
  Axon.input({nil, 30}, "input")
  |> Axon.dense(256)
  |> Axon.relu()
  |> Axon.dense(256)
  |> Axon.relu()
  |> Axon.dropout(rate: 0.3)
  |> Axon.dense(256)
  |> Axon.relu()
  |> Axon.dropout(rate: 0.3)
  |> Axon.dense(1)
  |> Axon.sigmoid()
```

```elixir
fraud =
  Nx.sum(train_targets)
  |> Nx.to_number()

legit = Nx.size(train_targets) - fraud

loss =
  &Axon.Losses.binary_cross_entropy(
    &1,
    &2,
    negative_weight: 1 / legit,
    positive_weight: 1 / fraud,
    reduction: :mean
  )

optimizer = Axon.Optimizers.adam(0.01)

:ok
```

```elixir
model_state =
  model
  |> Axon.Loop.trainer(loss, optimizer)
  |> Axon.Loop.metric(:precision)
  |> Axon.Loop.metric(:recall)
```

```elixir
model_state = model_state |> Axon.Loop.run(training_data, %{}, epochs: 2)
```

```elixir
model
|> Axon.serialize(%{model_state: model_state})
|> then(&File.write!("Projects/elixir_conf/models/simple_model.axon", &1))
```

## Test the Model

```elixir
{read_model, params} =
  File.read!("Projects/elixir_conf/models/simple_model.axon")
  |> Axon.deserialize()

model
```

```elixir
IO.inspect(">> Fradulent data set output")

model
|> Axon.Loop.evaluator()
|> Axon.Loop.metric(:true_positives, "fraud_declined", :running_sum)
|> Axon.Loop.metric(:true_negatives, "legit_accepted", :running_sum)
|> Axon.Loop.metric(:false_positives, "legit_declined", :running_sum)
|> Axon.Loop.metric(:false_negatives, "fraud_accepted", :running_sum)
|> Axon.Loop.run(test_batch, model_state)
```

# Nx in Action / Novice / Iris / LinReg

```elixir
Mix.install([
  {:axon, "~> 0.1.0"},
  {:exla, "~> 0.2.2"},
  {:nx, "~> 0.2.1"},
  {:explorer, "~> 0.2.0"},
  {:kino, "~> 0.6.2"},
  {:kino_vega_lite, "~> 0.1.1"},
  {:req, "~> 0.3.0"},
  {:scidata, "~> 0.1.9"},
  {:vega_lite, "~> 0.1.4"}
])
```

## Question

Can we use Linear Regression to prediect Iris species?

![](images/iris.png)

## Load

With the use of Explorer, we can easily load the iris data into a dataframe.

```elixir
{features, targets} = Scidata.Iris.download()
```

```elixir
feature_max =
  Nx.tensor(features)
  |> Nx.reduce_max(axes: [0], keep_axes: true)

inputs =
  Enum.map(features, fn feature ->
    Nx.divide(Nx.tensor(feature), feature_max)
  end)

targets =
  Enum.map(targets, fn t ->
    Nx.tensor([t])
  end)

data = Enum.zip([inputs, targets])
```

```elixir
set_size = Enum.count(data)
train_size = ceil(0.85 * set_size)
data = Enum.shuffle(data)
train_set = Enum.slice(data, 0, train_size)
test_set = Enum.slice(data, train_size, set_size - train_size)
```

```elixir
scalar = fn tensor ->
  tensor |> Nx.to_flat_list() |> List.first()
end
```

```elixir
defmodule LinReg do
  import Nx.Defn

  @epochs 100
  @learning_rate 0.02

  defn predict({m, b}, x) do
    m * x + b
  end

  defn loss(params, x, y) do
    y_pred = predict(params, x)
    Nx.mean(Nx.power(y - y_pred, 2))
  end

  defn update({m, b} = params, inp, tar) do
    {grad_m, grad_b} = grad(params, &loss(&1, inp, tar))

    {
      m - grad_m * @learning_rate,
      b - grad_b * @learning_rate
    }
  end

  def train(data) do
    # match type & shape of inputs {4, 1} & targets {1}
    init_feature = Nx.random_normal({4, 1}, 0.0, 0.1)
    init_target = Nx.tensor([1], type: {:s, 64})
    init_params = {init_feature, init_target}

    for _ <- 1..@epochs, reduce: init_params do
      acc ->
        data
        |> Enum.reduce(
          acc,
          fn {x, y}, current_params ->
            update(current_params, x, y)
          end
        )
    end
  end
end
```

```elixir
model = LinReg.train(train_set)

test_set
|> Enum.each(fn {input, truth} ->
  prediction =
    LinReg.predict(model, input)
    |> scalar.()

  IO.inspect(
    "Actual: #{scalar.(truth)}. Predicted: #{prediction}. Loss: #{scalar.(truth) - prediction}"
  )
end)
```


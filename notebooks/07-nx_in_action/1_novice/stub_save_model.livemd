### Save the Model

```elixir
model
|> Axon.serialize(%{model_state: model_state})
|> then(&File.write!("Projects/elixir_conf/models/simple_haberman_model.axon", &1))
```

todo description of the Axon evaluator, metrics, and run

```elixir
{read_model, _params} =
  File.read!("Projects/elixir_conf/models/simple_haberman_model.axon")
  |> Axon.deserialize()

results =
  read_model
  |> Axon.Loop.evaluator()
  |> Axon.Loop.metric(:true_positives, "true_positive", :running_sum)
  |> Axon.Loop.metric(:true_negatives, "true_negative", :running_sum)
  |> Axon.Loop.metric(:false_positives, "false_positive", :running_sum)
  |> Axon.Loop.metric(:false_negatives, "false_negative", :running_sum)
  |> Axon.Loop.run(test_batch, model_state)
  |> Map.get(0)
  |> Enum.map(fn {k, v} ->
    %{
      "result" => k |> String.replace("_", " ") |> String.capitalize(),
      "count" => Nx.to_number(v)
    }
  end)

alias VegaLite, as: Vl

Vl.new(width: 500, height: 500)
|> Vl.data_from_values(results)
|> Vl.mark(:bar)
|> Vl.encode_field(:x, "result", type: :nominal, axis: [label_angle: 0])
|> Vl.encode_field(:y, "count", type: :quantitative)
```

## Predict

### TODO define prediction

```elixir
[prediction_batch | _] = train_batch_inputs

IO.inspect(prediction_batch)

{read_model, params} =
  File.read!("Projects/elixir_conf/models/simple_haberman_model.axon")
  |> Axon.deserialize()

# prediction_batch = Nx.to_batched_list(prediction_batch, 2)
Axon.predict(read_model, params, prediction_batch)
```

## Advanced Challenge

Can you increase the accuracy of your predictions using Multiple Regression by adding more variables, like the weight of the car?

The goal would be to model the CO2 emissions as a function of several car engines features.

You could even get a larger dataset with additional features [here](https://raw.githubusercontent.com/amercader/car-fuel-and-emissions/master/data.csv).
